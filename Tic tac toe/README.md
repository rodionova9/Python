1) Несмотря на то, что сама по себе игра крестики-нолики не слишком сложная, ее написание будет разбито на несколько уроков. И первое, что нужно сделать, это отображение игрового поля. Для того, чтобы легче ориентироваться и лучше понимать написанный код, прорисовку игрового поля нужно сделать в отдельной функции.

Создайте функцию и назовите ее draw_state. Эта функция должна принимать один параметр — состояние игры.

Состояние игры можно представить как список из 9-ти элементов, где элемент с индексом 0, это верхняя левая клетка:

Если элемент списка None, в клетке нет ни крестика, ни нолика. Если элемент списка равен строке "o", в клетке должен быть нарисован нолик, а если "x" — крестик. То есть, такой код

GAME_STATE = ["x", None, None, "x", "o", None, None, None, "o"]
draw_state(GAME_STATE)


2)Следующим шагом в создании игры как раз и будет обработка хода пользователя, поэтому для начала давайте договоримся, что компьютер у нас будет играть за ноликов, а пользователь — за крестиков.

Для того, чтобы хранить состояние игры создайте переменную GAME_STATE. При объявлении она должна быть списком из 9 значений None. Переменная должна быть глобальной, то есть объявить ее нужно вне каких‑либо функций.

Также нужно создать функцию-обработчик клика по холсту. Функция должна принимать два аргумента — координаты x и y, а называться она должна click

По координатам клика эта функция должна ставить в нужный индекс списка GAME_STATE символ 'x' и вызывать написанную в прошлом уроке функцию перерисовки игрового поля draw_state с аргументом GAME_STATE. Соответствие индексов и клеток показано на рисунке ниже:

Алгоритм вычисления нужного индекса нужно придумать самостоятельно.

Не забудьте, что для привязки функции к обработке события нужно использовать canvas.set_onclick, а для того, чтобы программа ожидала клика по холсту, в конце программы должен быть вызов canvas.listen, описание которого можно посмотреть в справочнике.

3) Следующий шаг — создание бота, который будет играть против нас за ноликов.

Создайте функцию и назовите ее get_bot_move. Эта функция должна принимать в качестве аргумента состояние игры, как и функция draw_state, а возвращать должна случайный индекс этого состояния игры, который еще не занят. Эта функция не должна изменять состояние игры.

Как только эта функция будет готова, нужно доработать функцию-обработчик клика, которая была написана в прошлом уроке.

Во‑первых, ставить крестик в нужный индекс и перерисовывать игровое поле только тогда, когда этот индекс свободен, то есть равен None.

Во‑вторых, если индекс был свободен и в него поставлен крестик, должна быть вызвана функция get_bot_move. В качестве аргумента ей надо передать глобальное состояние игры GAME_STATE и в полученный с ее помощью индекс нужно поставить английскую букву «o». После этого игровое поле должно быть перерисовано с помощью функции draw_state

4) Есть три варианта завершения игры в крестики-нолики: победа ноликов, победа крестиков или ничья, если все клетки игрового поля заполнены, но нет ни трех крестиков, ни трех ноликов, расположенных в одну линию.

Для определения состояния игры нужно написать функцию get_winner. Эта функция должна принимать в качестве аргумента состояние игры, как и функция draw_state. В зависимости от состояния игрового поля get_winner должна возвращать следующие значения:

строку 'x_win', если на поле есть три крестика в одну линию или по диагоналям;
строку 'o_win', если на поле есть три нолика в одну линию или по диагоналям;
строку 'draw', если все клетки заполнены, но победителя нет:
None, если победителя нет и остались свободные клетки.

5) Написанная в прошлом уроке функция get_winner должна вызываться дважды в внутри функции click. Первый раз — после того, как будет поставлен крестик пользователя. В качестве аргумента ей надо передать текущее состояние игры GAME_STATE. Если функция вернет что‑то, кроме None, должна быть выведена соответствующая надпись о победителе или ничьей на экран с помощью canvas.fill_text или canvas.stroke_text. Если функция вернет None, бот должен поставить нолик. После этого функция get_winner должна быть вызвана второй раз с обновленным состоянием игры и аналогичными проверками на победителя.

Да, после того, как на экран будет выведена информация о победителе или ничьей, можно сделать паузу в несколько секунд, перезаписать состояние игры списком из девяти None и начать игру заново.
